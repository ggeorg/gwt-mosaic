#summary One-sentence summary of this page.
#sidebar TableOfContents

= Introduction =

A modifier feature is a feature that has a child (which can be a group or features). A modifier will modify the display of its child features in some way.

= Details =

The basic set of modifiers are:
  * Fade
  * Translator
  * Clipped

== Translator ==

A translator moves the position of its children on the page by a relative delta-x and delta-y. The delta values can be animated over time, and smooth animations can be had with various tweening functions. Translators work on pre-computed values linked into a path by linear interpolation.

A translator is split into two piecces: the actual translator, and the translator model that holds the points.


<wiki:gadget url="http://mosaic.arkasoft.com/gwt-mosaic-translator-wiki.xml?v=1" height="256" width="512" border="0"/>

Example:

{{{
import org.gwt.mosaic2g.client.animator.AnimationClient;
import org.gwt.mosaic2g.client.animator.AnimationEngine;
import org.gwt.mosaic2g.client.scene.GrinFile;
import org.gwt.mosaic2g.client.scene.InterpolatedModelParser;
import org.gwt.mosaic2g.client.scene.Scene;
import org.gwt.mosaic2g.client.scene.Segment;
import org.gwt.mosaic2g.client.scene.Show;
import org.gwt.mosaic2g.client.scene.Translator;
import org.gwt.mosaic2g.client.scene.control.Box;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.core.client.GWT;
import com.google.gwt.user.client.ui.RootLayoutPanel;

/**
 * Entry point classes define <code>onModuleLoad()</code>.
 */
public class Showcase implements EntryPoint {
	private final Scene scene = new Scene();

	/**
	 * This is the entry point method.
	 */
	public void onModuleLoad() {
		// Specify a GWT panel (here RootLayoutPanel) to render our scene graph.
		// Within the panel we add the scene. A scene is a top level area where
		// you can set the root node of a scene graph, which is always a show
		// node.
		RootLayoutPanel.get().add(scene);
		scene.setShow(createShow());

		// Create an AnimationEngine instance with all AnimationClient(s) it has
		// to manage (Scene implements the AnimationClient interface).
		final AnimationEngine animationEngine = new AnimationEngine(
				new AnimationClient[] { scene });
		// Start the animation engine.
		animationEngine.start();
	}

	private Show createShow() {
		Show show = new Show();
		
		Box box1 = new Box(show, 20, 20, 50, 50);
		box1.setBackground("orange");
		box1.setBorder("5px solid green");
		
		MyTranslatorModel tm = GWT.create(MyTranslatorModel.class);
		Translator translator = new Translator(show, tm.getModel());
		translator.setPart(box1);
		
		Segment segment = new Segment(show);
		segment.add(translator);
		
		show.activateSegment(segment);
		
		return show;
	}

	@GrinFile(value = "translator_model.txt")
	interface MyTranslatorModel extends InterpolatedModelParser {
	};
}
}}}

The translator model is declared in `translator_model.txt`:

{{{
translator_model {
	0		0		0		start
	25		200		0		linear-relative
	50		200		100		ease-out-back
	75		0		100		linear-relative
	100		0		0		ease-in-back
} repeat 0 ;
}}}

The BNF describing the syntaxt of a translator model txt file:

{{{
    translator_model ::= "translator_model" "{" trans_key_frame * "}" 
			    [ "repeat" frame_number ] 
			    [ loop_count ] ";"

        # Use "offscreen" keyword for x,y position to place a feature 
        # off the screen without causing the animation engine to repaint extra
        # region.

    trans_key_frame ::= frame_number x y trans_tween

    trans_tween ::=    "linear-relative"  [ "max-error" integer ]
    		     | tween_type

    	# linear and linear-relative are special for translations.  You
	# should always use linear-relative; that's linear interpolation
	# using relative coordinates for the child nodes (that is, the
	# interpolation specifies delta-x and delta-y for each child).
}}}


== Clipped ==

A clipped modifier clips its children within a clipping rectangle. This can be useful in conjunction with a translator, to make a set of child nodes slide out.

Example:

{{{
import org.gwt.mosaic2g.client.animator.AnimationClient;
import org.gwt.mosaic2g.client.animator.AnimationEngine;
import org.gwt.mosaic2g.client.scene.Clipped;
import org.gwt.mosaic2g.client.scene.GrinFile;
import org.gwt.mosaic2g.client.scene.InterpolatedModelParser;
import org.gwt.mosaic2g.client.scene.Scene;
import org.gwt.mosaic2g.client.scene.Segment;
import org.gwt.mosaic2g.client.scene.Show;
import org.gwt.mosaic2g.client.scene.Translator;
import org.gwt.mosaic2g.client.scene.control.Box;
import org.gwt.mosaic2g.client.util.Rectangle;

import com.google.gwt.core.client.EntryPoint;
import com.google.gwt.core.client.GWT;
import com.google.gwt.user.client.ui.RootLayoutPanel;

/**
 * Entry point classes define <code>onModuleLoad()</code>.
 */
public class Showcase implements EntryPoint {
	private final Scene scene = new Scene();

	/**
	 * This is the entry point method.
	 */
	public void onModuleLoad() {
		// Specify a GWT panel (here RootLayoutPanel) to render our scene graph.
		// Within the panel we add the scene. A scene is a top level area where
		// you can set the root node of a scene graph, which is always a show
		// node.
		RootLayoutPanel.get().add(scene);
		scene.setShow(createShow());

		// Create an AnimationEngine instance with all AnimationClient(s) it has
		// to manage (Scene implements the AnimationClient interface).
		final AnimationEngine animationEngine = new AnimationEngine(
				new AnimationClient[] { scene });
		// Start the animation engine.
		animationEngine.start();
	}

	private Show createShow() {
		Show show = new Show();

		Box box1 = new Box(show, 20, 20, 50, 50);
		box1.setBackground("orange");
		box1.setBorder("5px solid green");

		MyTranslatorModel tm = GWT.create(MyTranslatorModel.class);
		Translator translator = new Translator(show, tm.getModel());
		translator.setPart(box1);

		Clipped clipped = new Clipped(show, new Rectangle(10, 10, 250, 150));
		clipped.setPart(translator);
		
		// A box that shows the clipping rectangle
		Box box2 = new Box(show, 10, 10, 250, 150);
		box2.setBorder("1px dotted red");

		Segment segment = new Segment(show);
		segment.add(box2);
		segment.add(clipped);

		show.activateSegment(segment);

		return show;
	}

	@GrinFile(value = "translator_model.txt")
	interface MyTranslatorModel extends InterpolatedModelParser {
	};
}
}}}

== Tween Type ==

The BNF for `tween_type`:

{{{
    tween_type ::=
              "linear"  [ "max-error" integer ]
	    | "start"
	    | "ease-in-quad" [ "max-error" integer ]
	    | "ease-out-quad" [ "max-error" integer ]
	    | "ease-in-out-quad" [ "max-error" integer ]
	    | "ease-in-cubic" [ "max-error" integer ]
	    | "ease-out-cubic" [ "max-error" integer ]
	    | "ease-in-out-cubic" [ "max-error" integer ]
	    | "ease-in-quart" [ "max-error" integer ]
	    | "ease-out-quart" [ "max-error" integer ]
	    | "ease-in-out-quart" [ "max-error" integer ]
	    | "ease-in-quint" [ "max-error" integer ]
	    | "ease-out-quint" [ "max-error" integer ]
	    | "ease-in-out-quint" [ "max-error" integer ]
	    | "ease-in-sine" [ "max-error" integer ]
	    | "ease-out-sine" [ "max-error" integer ]
	    | "ease-in-out-sine" [ "max-error" integer ]
	    | "ease-in-expo" [ "max-error" integer ]
	    | "ease-out-expo" [ "max-error" integer ]
	    | "ease-in-out-expo" [ "max-error" integer ]
	    | "ease-in-circ" [ "max-error" integer ]
	    | "ease-out-circ" [ "max-error" integer ]
	    | "ease-in-out-circ" [ "max-error" integer ]
	    | "ease-in-elastic" [ "amplitude" double ] [ "period" double ] 
	    			[ "max-error" integer ]
	    | "ease-out-elastic" [ "amplitude" double ] [ "period" double ] 
	    			 [ "max-error" integer ]
	    | "ease-in-out-elastic" [ "amplitude" double ] [ "period" double ] 
	    			    [ "max-error" integer ]
	    | "ease-in-back" [ "overshoot" double ] [ "max-error" integer ]
	    | "ease-out-back" [ "overshoot" double ] [ "max-error" integer ]
	    | "ease-in-out-back" [ "overshoot" double ] [ "max-error" integer ]
	    | "ease-in-bounce" [ "max-error" integer ]
	    | "ease-out-bounce" [ "max-error" integer ]
	    | "ease-in-out-bounce" [ "max-error" integer ]
	    | "ease-points" "{" tween-point * "}" [ "max-error" integer ]

        # The tween type give the algorithm used for the transition from the
	# previous key frame to the present one.
	#
	# start is a synonym for linear.  It's intended to be
	# used for the first keyframe, since the tween type for the
	# first keyframe is meaningless.
	#
	# The other tweening types are described in 
	# com.robertpenner.PennerEasing, and in his book, which you can
	# find out about at http://robertpenner.com.
	#
	# max-error says how many units of error you're willing to tolerate
	# when the compiler uses linear interpolation segments to approximate
	# tweening.  It defaults to 0, that is, no error.  Setting a higher
	# tolerance will result in a smaller .grin file and less runtime
	# memory usage.  The grin compiler tells you how many key frames
	# are added for interpolation due to tweening; if the number looks
	# huge, consider increasing the error tolerance.

    tween_point ::= "(" integer * ")"
}}}